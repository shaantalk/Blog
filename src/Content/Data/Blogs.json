[{"id":"2","title":"Hoisting and Temporal Dead Zone","type":"javascript","author":"Santanu Panda","date":"January 1, 2020","content":"\n## Hoisting of variables and functions in JS\n\n**Hoisting** is mechanism where variables and function declarations are moved to the top of their scope before code execution.\n\nThe following steps are followed by JS during hoisting :\n\nStep 1 : At compile time, the variable declaration is added to the enclosing lexical scope\n\nStep 2 : At runtime, when the scope is entered any variables added to the lexical environment are initialised to the undefined value so they are available to use in the scope\n\n```js\nconsole.log(greetings);\nvar greetings = \"Hello\";\n```\n\nThe above code is interpreted as this:\n\n```js\nvar greetings;\nconsole.log(greetings); // greetings is undefined\ngreetings = \"Hello\";\n```\n\n## Temporal Dead Zone in JS\n\n**Temporal Dead Zone** is a behaviour in JavaScript that occurs when declaring a variable with the **let** and **const** keywords, but not with var.\n\nThe salient difference between `let` / `const` and `var` is that if you access `var` before it is declared, it is undefined. But if you do the same for `let` and `const`, they throw a `ReferenceError`.\n\nWhen variables get hoisted, `var` gets `undefined` initialised to its value by default in the process of hoisting. `let` and `const` also get hoisted, but don't get set to `undefined` when they get hoisted. So, the Step 2 of hoisting don't occur in case of `let` and `const`.\n\nLet's try this using **VAR** :\n\nWe don't get the error in case of var, instead, we get undefined.\n\n```js\nfunction noError() {\n  var greetings = \"Hello World!\";\n  console.log(greetings);\n}\nnoError();\n\nfunction yesError() {\n  console.log(greetings); //undefined\n  var greetings = \"Hello World!\";\n}\nyesError();\n```\n\nIf we try to access **LET** before it is declared then get Reference Error.\n\n```js\nfunction noError() {\n  let greetings = \"Hello World!\";\n  console.log(greetings);\n}\nnoError();\n\nfunction yesError() {\n  console.log(greetings); // ReferenceError: greetings is not defined\n  let greetings = \"Hello World!\";\n}\nyesError();\n```\n\nIf we try to access **CONST** before it is declared then get Reference Error.\n\n```js\nfunction noError() {\n  const greetings = \"Hello World!\";\n  console.log(greetings);\n}\nnoError();\n\nfunction yesError() {\n  console.log(greetings); // ReferenceError: greetings is not defined\n  const greetings = \"Hello World!\";\n}\nyesError();\n```\n\n**Note:** The only difference between `const` and `let` is that when they are hoisted, their values don't get defaulted to `undefined`.\n"},{"id":"1","title":"Const, Let and Var.","type":"javascript","author":"Santanu Panda","date":"January 1, 2020","content":"\n## VAR\n\n### Before ES-6 var was used everywhere\n\n```js\nvar greetings = \"hey hi\";\nfunction newFunction() {\n  var hello = \"hello\";\n  console.log(hello);\n}\nconsole.log(greetings);\nconsole.log(hello); // ReferenceError: hello is not defined\n```\n\nThe problem with **var** are best explained using the following code :\n\n```js\nvar greetings = \"Hi\";\nvar condition = 4;\nconsole.log(greetings); //Hi\nif (condition > 3) {\n  var greetings = \"Hello\";\n}\nconsole.log(greetings); //Hello\n```\n\nVar is scoped globally, ideally the programmer wanted the value to be \"Hello\" only inside the if block.\n\n## LET\n\n### Block scoped replacement for var. This is currently the most widely used way of declaring variable in JS\n\n```js\nlet greetings = \"Hi\";\nlet condition = 4;\nif (condition > 3) {\n  let greetings = \"Hello\";\n  console.log(greetings); //Hello\n}\nconsole.log(greetings); //Hi\n```\n\n**Note:** let can be updated but not re-declared.\n\n```js\nlet greetings = \"Hi\";\ngreetings = \"Hello\";\nconsole.log(greetings); //Hello\nlet greetings = \"Hi\";\nlet greetings = \"Hello\"; // error: Identifier 'greeting' has already been declared\nconsole.log(greetings);\n```\n\n## CONST\n\n### Const are constant values they can be initialised just once.\n\n```js\nconst greetings = \"Hi\";\ngreetings = \"Hello\"; // error: Assignment to constant variable.\nconst greetings = \"Hi\";\nconst greetings = \"Hello\"; // error: Identifier 'greeting' has already been declared\n```\n\nWhen it comes to const assigned to JS Objects we cannot reassign the whole object to a new object but we can update values of each element in the object. Like this:\n\n```js\nconst greetings = {\n  message: \"Hi\",\n  times: 4,\n};\n\n// Cannot do this\nconst greetings = {\n  words: \"Hello\",\n  number: \"five\",\n}; // error: Assignment to constant variable.\n\n// Can do this:\ngreetings.message = \"Hello\";\nconsole.log(greetings);\n```\n"}]